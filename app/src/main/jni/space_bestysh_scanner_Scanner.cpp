/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <android/bitmap.h>
#include <stdlib.h>

#include <opencv2/opencv.hpp>

#include "space_bestysh_scanner_Scanner.h"
/* Header for class space_bestysh_scanner_scanner */
#include <android/log.h>

#ifndef eprintf
#define eprintf(...) __android_log_print(ANDROID_LOG_ERROR,"ysh",__VA_ARGS__)
#endif

#ifndef LOGD
#define LOGD(...) __android_log_print(ANDROID_LOG_INFO,"ysh",__VA_ARGS__)
#endif


#define RGB565_R(p) ((((p) & 0xF800) >> 11) << 3)
#define RGB565_G(p) ((((p) & 0x7E0 ) >> 5)  << 2)
#define RGB565_B(p) ( ((p) & 0x1F  )        << 3)
#define MAKE_RGB565(r,g,b) ((((r) >> 3) << 11) | (((g) >> 2) << 5) | ((b) >> 3))

#define RGBA_A(p) (((p) & 0xFF000000) >> 24)
#define RGBA_R(p) (((p) & 0x00FF0000) >> 16)
#define RGBA_G(p) (((p) & 0x0000FF00) >>  8)
#define RGBA_B(p)  ((p) & 0x000000FF)
#define MAKE_RGBA(r,g,b,a) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b))


#include <math.h>
#include <iostream>

using namespace cv;
using namespace std;

bool compareContourAreas(std::vector<cv::Point> contour1, std::vector<cv::Point> contour2) {
    double i = fabs(contourArea(cv::Mat(contour1)));
    double j = fabs(contourArea(cv::Mat(contour2)));
    return (i > j);
}

bool compareXCords(Point p1, Point p2)
{
    return (p1.x < p2.x);
}

bool compareYCords(Point p1, Point p2)
{
    return (p1.y < p2.y);
}

bool compareDistance(pair<Point, Point> p1, pair<Point, Point> p2)
{
    return (norm(p1.first - p1.second) < norm(p2.first - p2.second));
}

double _distance(Point p1, Point p2)
{
    return sqrt(((p1.x - p2.x) * (p1.x - p2.x)) +
                ((p1.y - p2.y) * (p1.y - p2.y)));
}

void resizeToHeight(Mat src, Mat &dst, int height)
{
    Size s = Size(src.cols * (height / double(src.rows)), height);
    resize(src, dst, s, CV_INTER_NN);
}

void orderPoints(vector<Point> inpts, vector<Point> &ordered)
{
    sort(inpts.begin(), inpts.end(), compareXCords);
    vector<Point> lm(inpts.begin(), inpts.begin() + 2);
    vector<Point> rm(inpts.end() - 2, inpts.end());

    sort(lm.begin(), lm.end(), compareYCords);
    Point tl(lm[0]);
    Point bl(lm[1]);
    vector<pair<Point, Point> > tmp;
    for (size_t i = 0; i< rm.size(); i++)
    {
        tmp.push_back(make_pair(tl, rm[i]));
    }

    sort(tmp.begin(), tmp.end(), compareDistance);
    Point tr(tmp[0].second);
    Point br(tmp[1].second);

    ordered.push_back(tl);
    ordered.push_back(tr);
    ordered.push_back(br);
    ordered.push_back(bl);
}

void fourPointTransform(Mat src, Mat &dst, vector<Point> pts)
{
    vector<Point> ordered_pts;
    orderPoints(pts, ordered_pts);

    double wa = _distance(ordered_pts[2], ordered_pts[3]);
    double wb = _distance(ordered_pts[1], ordered_pts[0]);
    double mw = max(wa, wb);

    double ha = _distance(ordered_pts[1], ordered_pts[2]);
    double hb = _distance(ordered_pts[0], ordered_pts[3]);
    double mh = max(ha, hb);

    Point2f src_[] =
            {
                    Point2f(ordered_pts[0]),
                    Point2f(ordered_pts[1]),
                    Point2f(ordered_pts[2]),
                    Point2f(ordered_pts[3]),
            };
    Point2f dst_[] =
            {
                    Point2f(0, 0),
                    Point2f(mw - 1, 0),
                    Point2f(mw - 1, mh - 1),
                    Point2f(0, mh - 1)
            };
    Mat m = getPerspectiveTransform(src_, dst_);
    warpPerspective(src, dst, m, Size(mw, mh));
}

void preProcess(Mat src, Mat &dst)
{
    cv::Mat imageOpen, imageClosed, imageBlurred;

    cv::Mat structuringElmt = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(4, 4));
    morphologyEx(src, imageOpen, cv::MORPH_OPEN, structuringElmt);
    morphologyEx(imageOpen, imageClosed, cv::MORPH_CLOSE, structuringElmt);

    Mat thres;
    double high_thres = threshold(imageClosed, thres, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU)*40;
    double low_thres = high_thres*0.3 ;
    GaussianBlur(imageClosed, imageBlurred, Size(7, 7), 0);
    Canny(imageBlurred, dst, low_thres, high_thres, 7);
}


/*
 * Class:     space_bestysh_scanner_scanner
 * Method:    scannerCrop
 * Signature: (Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;
 */
JNIEXPORT jobject JNICALL Java_space_bestysh_scanner_Scanner_scannerCrop(JNIEnv *env, jobject, jobject inBitmap)
{
    LOGD("into function");
    //获取图片信息
    AndroidBitmapInfo imgInfo;
    AndroidBitmap_getInfo(env,inBitmap,&imgInfo);
    // Check format, only RGB565 & RGBA are supported
    if (imgInfo.width <= 0 || imgInfo.height <= 0 ||
        (imgInfo.format != ANDROID_BITMAP_FORMAT_RGB_565 && imgInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888)) {
        eprintf("invalid bitmap\n");
        env->ThrowNew(env->FindClass("java/io/IOException"), "invalid bitmap");
        return NULL;
    }

    //获取图片像素
    void * pixels = NULL;
    int res = AndroidBitmap_lockPixels(env, inBitmap, &pixels);
    if (pixels == NULL) {
        eprintf("fail to lock bitmap: %d\n", res);
        env->ThrowNew(env->FindClass("java/io/IOException"), "fail to open bitmap");
        return NULL;
    }

    LOGD("get image");



    //将像素转化为cv::Mat
    Mat orig=Mat(imgInfo.height,imgInfo.width,CV_8UC4,pixels);

    Mat image=orig.clone();


    //改变图片大小（图片大小归一化）
    double ratio = double(image.rows) / 800.0;
    resizeToHeight(image, image, 800);

    //获取缩放后的图像面积
    double total_area = image.rows*image.rows;
    cout << "total area" << total_area << endl;
    double allow_area = total_area / 10.0;

    //三通道分别边缘检测，或逻辑运算
    Mat edged;
    vector<Mat> channals;
    vector<Mat> edgeds;
    edgeds.resize(3);

    split(image, channals);

    for (int i = 0; i < 3; i++)
    {
        preProcess(channals[i], edgeds[i]);
    }

    bitwise_or(edgeds[0], edgeds[1], edged);
    bitwise_or(edged, edgeds[2], edged);

    //膨胀，防止边缘断点
    dilate(edged, edged, Mat(3, 3, CV_8U), Point(-1, -1), 1);

    Mat more_edged;
    dilate(edged, more_edged, Mat(3, 3, CV_8U), Point(-1, -1), 3);

    Mat line_map(edged.rows, edged.cols, CV_8UC1, Scalar(0));

    vector<Vec4i> lines;
    HoughLinesP(edged, lines, 2.0, CV_PI / 90.0, 500 / 4, 500 / 4, 40);
    for (size_t i = 0; i < lines.size(); i++) {
        Vec4i v = lines[i];
        // for visualization only
        line(line_map, Point(v[0], v[1]), Point(v[2], v[3]), 255, 2, CV_AA);
    }

    bitwise_and(more_edged, line_map, more_edged);
    bitwise_or(edged, more_edged, edged);



    //补充断裂点
    std::vector<cv::Mat> kernal_list;

    cv::Mat kernel1 = (Mat_<float>(5, 5) << 0.2, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.2, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.2, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.2);
    cv::Mat kernel2;
    cv::flip(kernel1, kernel2, 0);//上下翻转
    cv::Mat kernel3 = (Mat_<float>(5, 5) << 0.0, 0.0, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.2, 0.0, 0.0);
    cv::Mat kernel4 = kernel3.t();

    kernal_list.push_back(kernel1);
    kernal_list.push_back(kernel2);
    kernal_list.push_back(kernel3);
    kernal_list.push_back(kernel4);

    for (int i = 0; i < kernal_list.size();i++)
    {
        cv::Mat edge2;
        cv::filter2D(edged, edge2, CV_8U, kernal_list[i]);
        edge2 = cv::Mat(edge2 > 200);
        bitwise_or(edged, edge2, edged);
    }



    //计算闭合等高线
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;
    vector<vector<Point> > contours2;
    vector<vector<Point> > approx;

    findContours(edged, contours, hierarchy, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);

    //筛选面积大于阈值的contour
    for (int k = 0; k< contours.size(); k++)
    {
        double temp = fabs(contourArea(cv::Mat(contours[k])));
        if (temp>allow_area)
        {
            contours2.push_back(contours[k]);
        }
    }

    //多边形逼近算法
    approx.resize(contours2.size());
    size_t i, j;
    for (i = 0; i< contours2.size(); i++)
    {
        double peri = arcLength(contours2[i], true);
        approxPolyDP(contours2[i], approx[i], 0.1 * peri, true);
    }


    //对多边形面积进行排序，最大面积四边形认为是文档
    sort(approx.begin(), approx.end(), compareContourAreas);
    int temp1 = 1000000;
    for (i = 0; i< approx.size(); i++)
    {
        drawContours(image, approx, i, 255, 2);
        cout << approx[i].size() << endl;
        if (approx[i].size() == 4)
        {
            temp1 = i;
            break;
        }
    }

    //透视变换
    Mat warped;
    if (temp1 < approx.size())
    {
        for (j = 0; j< 4; j++)
        {
            approx[temp1][j] *= ratio;
        }

        fourPointTransform(orig, warped, approx[temp1]);
    }else{
        return NULL;
    }


    LOGD("warped width:%d, height:%d",warped.cols,warped.rows);


    void* mPixels=warped.data;


    //创建Bitmap Config 类
    jclass bitmapCfgCls=env->FindClass("android/graphics/Bitmap$Config");
    jmethodID bmpClsValueOfMid = env->GetStaticMethodID(bitmapCfgCls,
                                                        "valueOf",
                                                        "(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;");//获取bitmapCfgCls类的静态方法id
    jobject jBmpCfg = env->CallStaticObjectMethod(bitmapCfgCls, bmpClsValueOfMid, env->NewStringUTF("ARGB_8888"));//获取配置对象
    // Creating a Bitmap Class
    jclass bmpCls = env->FindClass("android/graphics/Bitmap");
    jmethodID createBitmapMid = env->GetStaticMethodID(bmpCls, "createBitmap", "(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;");
    jobject resultBipmap = env->CallStaticObjectMethod(bmpCls, createBitmapMid, warped.cols, warped.rows, jBmpCfg);






    //给结果Bitmap赋值
    void* resultPixels=NULL;
    AndroidBitmap_lockPixels(env, resultBipmap, &resultPixels);

    memcpy(resultPixels,mPixels,warped.cols*warped.rows*4);

    AndroidBitmap_unlockPixels(env, resultBipmap);
    AndroidBitmap_unlockPixels(env, inBitmap);



    return resultBipmap;
}



JNIEXPORT jfloatArray JNICALL Java_space_bestysh_scanner_Scanner_scannerCropPoint
        (JNIEnv * env, jobject, jobject inBitmap)
{
    LOGD("into function");
    //获取图片信息
    AndroidBitmapInfo imgInfo;
    AndroidBitmap_getInfo(env,inBitmap,&imgInfo);
    // Check format, only RGB565 & RGBA are supported
    if (imgInfo.width <= 0 || imgInfo.height <= 0 ||
        (imgInfo.format != ANDROID_BITMAP_FORMAT_RGB_565 && imgInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888)) {
        eprintf("invalid bitmap\n");
        env->ThrowNew(env->FindClass("java/io/IOException"), "invalid bitmap");
        return NULL;
    }

    //获取图片像素
    void * pixels = NULL;
    int res = AndroidBitmap_lockPixels(env, inBitmap, &pixels);
    if (pixels == NULL) {
        eprintf("fail to lock bitmap: %d\n", res);
        env->ThrowNew(env->FindClass("java/io/IOException"), "fail to open bitmap");
        return NULL;
    }

    LOGD("get image");



    //将像素转化为cv::Mat
    Mat orig=Mat(imgInfo.height,imgInfo.width,CV_8UC4,pixels);

    Mat image=orig.clone();


    //改变图片大小（图片大小归一化）
    double ratio = double(image.rows) / 800.0;
    resizeToHeight(image, image, 800);

    //获取缩放后的图像面积
    double total_area = image.rows*image.rows;
    cout << "total area" << total_area << endl;
    double allow_area = total_area / 10.0;

    //三通道分别边缘检测，或逻辑运算
    Mat edged;
    vector<Mat> channals;
    vector<Mat> edgeds;
    edgeds.resize(3);

    split(image, channals);

    for (int i = 0; i < 3; i++)
    {
        preProcess(channals[i], edgeds[i]);
    }

    bitwise_or(edgeds[0], edgeds[1], edged);
    bitwise_or(edged, edgeds[2], edged);

    //膨胀，防止边缘断点
    dilate(edged, edged, Mat(3, 3, CV_8U), Point(-1, -1), 1);

    Mat more_edged;
    dilate(edged, more_edged, Mat(3, 3, CV_8U), Point(-1, -1), 3);

    Mat line_map(edged.rows, edged.cols, CV_8UC1, Scalar(0));

    vector<Vec4i> lines;
    HoughLinesP(edged, lines, 2.0, CV_PI / 90.0, 500 / 4, 500 / 4, 40);
    for (size_t i = 0; i < lines.size(); i++) {
        Vec4i v = lines[i];
        // for visualization only
        line(line_map, Point(v[0], v[1]), Point(v[2], v[3]), 255, 2, CV_AA);
    }

    bitwise_and(more_edged, line_map, more_edged);
    bitwise_or(edged, more_edged, edged);



    //补充断裂点
    std::vector<cv::Mat> kernal_list;

    cv::Mat kernel1 = (Mat_<float>(5, 5) << 0.2, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.2, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.2, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.2);
    cv::Mat kernel2;
    cv::flip(kernel1, kernel2, 0);//上下翻转
    cv::Mat kernel3 = (Mat_<float>(5, 5) << 0.0, 0.0, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.2, 0.0, 0.0);
    cv::Mat kernel4 = kernel3.t();

    kernal_list.push_back(kernel1);
    kernal_list.push_back(kernel2);
    kernal_list.push_back(kernel3);
    kernal_list.push_back(kernel4);

    for (int i = 0; i < kernal_list.size();i++)
    {
        cv::Mat edge2;
        cv::filter2D(edged, edge2, CV_8U, kernal_list[i]);
        edge2 = cv::Mat(edge2 > 200);
        bitwise_or(edged, edge2, edged);
    }



    //计算闭合等高线
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;
    vector<vector<Point> > contours2;
    vector<vector<Point> > approx;

    findContours(edged, contours, hierarchy, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);

    //筛选面积大于阈值的contour
    for (int k = 0; k< contours.size(); k++)
    {
        double temp = fabs(contourArea(cv::Mat(contours[k])));
        if (temp>allow_area)
        {
            contours2.push_back(contours[k]);
        }
    }

    //多边形逼近算法
    approx.resize(contours2.size());
    size_t i, j;
    for (i = 0; i< contours2.size(); i++)
    {
        double peri = arcLength(contours2[i], true);
        approxPolyDP(contours2[i], approx[i], 0.1 * peri, true);
    }


    //对多边形面积进行排序，最大面积四边形认为是文档
    sort(approx.begin(), approx.end(), compareContourAreas);
    int temp1 = 1000000;
    for (i = 0; i< approx.size(); i++)
    {
        drawContours(image, approx, i, 255, 2);
        cout << approx[i].size() << endl;
        if (approx[i].size() == 4)
        {
            temp1 = i;
            break;
        }
    }

    //透视变换
    Mat warped;
    if (temp1 < approx.size())
    {
        for (j = 0; j< 4; j++)
        {
            approx[temp1][j] *= ratio;
        }

        //1.新建长度len数组
        jfloatArray jarr = env->NewFloatArray(8);
        //2.获取数组指针
        jfloat *arr = env->GetFloatArrayElements(jarr, NULL);
        //3.赋值
        arr[0]=(float)(approx[temp1][0].x);
        arr[1]=(float)(approx[temp1][0].y);
        arr[2]=(float)(approx[temp1][1].x);
        arr[3]=(float)(approx[temp1][1].y);
        arr[4]=(float)(approx[temp1][2].x);
        arr[5]=(float)(approx[temp1][2].y);
        arr[6]=(float)(approx[temp1][3].x);
        arr[7]=(float)(approx[temp1][3].y);

        /*
        for(int k=0;k<4;k++)
        {
            cv::circle(orig,approx[temp1][k],10,cv::Scalar(255,0,0,255),2);
        }
         */

        LOGD("arr");
        for(int k=0;k<8;k++)
        {
            LOGD("%f",arr[k]);
        }
        //4.释放资源//必须释放，否则无法返回
        env->ReleaseFloatArrayElements(jarr, arr, 0);
        //5.返回数组
        return jarr;


        //fourPointTransform(orig, warped, approx[temp1]);
    }else{
        return NULL;
    }

}


JNIEXPORT jobject JNICALL Java_space_bestysh_scanner_Scanner_scannerPointTransform
        (JNIEnv *env, jobject, jobject inBitmap, jfloatArray jarr)
{

    LOGD("into function");
    //获取图片信息
    AndroidBitmapInfo imgInfo;
    AndroidBitmap_getInfo(env,inBitmap,&imgInfo);
    // Check format, only RGB565 & RGBA are supported
    if (imgInfo.width <= 0 || imgInfo.height <= 0 ||
        (imgInfo.format != ANDROID_BITMAP_FORMAT_RGB_565 && imgInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888)) {
        eprintf("invalid bitmap\n");
        env->ThrowNew(env->FindClass("java/io/IOException"), "invalid bitmap");
        return NULL;
    }

    //获取图片像素
    void * pixels = NULL;
    int res = AndroidBitmap_lockPixels(env, inBitmap, &pixels);
    if (pixels == NULL) {
        eprintf("fail to lock bitmap: %d\n", res);
        env->ThrowNew(env->FindClass("java/io/IOException"), "fail to open bitmap");
        return NULL;
    }

    LOGD("get image");



    //将像素转化为cv::Mat
    Mat orig=Mat(imgInfo.height,imgInfo.width,CV_8UC4,pixels);
    Mat image=orig.clone();

    jfloat *arr = env->GetFloatArrayElements(jarr, NULL);


    vector<Point> approx;
    approx.resize(4);
    for(int i=0;i<4;i++)
    {
        approx[i]=Point((float)arr[2*i],(float)arr[2*i+1]);
    }

    LOGD("arr2");
    for(int k=0;k<8;k++)
    {
        LOGD("%f",arr[k]);
    }

    env->ReleaseFloatArrayElements(jarr, arr, 0);

    cv::Mat warped;

    fourPointTransform(orig, warped, approx);

    void* mPixels=warped.data;


    //创建Bitmap Config 类
    jclass bitmapCfgCls=env->FindClass("android/graphics/Bitmap$Config");
    jmethodID bmpClsValueOfMid = env->GetStaticMethodID(bitmapCfgCls,
                                                        "valueOf",
                                                        "(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;");//获取bitmapCfgCls类的静态方法id
    jobject jBmpCfg = env->CallStaticObjectMethod(bitmapCfgCls, bmpClsValueOfMid, env->NewStringUTF("ARGB_8888"));//获取配置对象
    // Creating a Bitmap Class
    jclass bmpCls = env->FindClass("android/graphics/Bitmap");
    jmethodID createBitmapMid = env->GetStaticMethodID(bmpCls, "createBitmap", "(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;");
    jobject resultBipmap = env->CallStaticObjectMethod(bmpCls, createBitmapMid, warped.cols, warped.rows, jBmpCfg);






    //给结果Bitmap赋值
    void* resultPixels=NULL;
    AndroidBitmap_lockPixels(env, resultBipmap, &resultPixels);

    memcpy(resultPixels,mPixels,warped.cols*warped.rows*4);

    AndroidBitmap_unlockPixels(env, resultBipmap);
    AndroidBitmap_unlockPixels(env, inBitmap);

    return resultBipmap;

}

